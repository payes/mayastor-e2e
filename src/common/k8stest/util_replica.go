package k8stest

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"mayastor-e2e/common/controlplane"
	agent "mayastor-e2e/common/e2e-agent"
	"mayastor-e2e/common/mayastorclient"

	logf "sigs.k8s.io/controller-runtime/pkg/log"
)

// ChecksumReplica checksums the partition p2 of the nvme target defined by the given uri
// It uses the e2e agent and the nvme client to connect to the target.
// the returned format is that generated by cksum: <checksum> <size> <device>
// e.g. "924018992 61849088 /dev/nvme0n1p2"
func ChecksumReplica(initiatorIP, targetIP, uri string, maxRetries int) (string, error) {
	var err error
	logf.Log.Info("checksumReplica", "nexusIP", initiatorIP, "nodeIP", targetIP, "uri", uri)

	nqnoffset := strings.Index(uri, "nqn.")
	nqnlong := uri[nqnoffset:]
	tailoffset := strings.Index(nqnlong, "?")
	nqn := nqnlong[:tailoffset]

	cmdArgs := []string{
		"nvme",
		"connect",
		"-a", targetIP,
		"-t", "tcp",
		"-s", "8420",
		"-n", nqn,
	}
	args := strings.Join(cmdArgs, " ")
	resp, err := agent.Exec(initiatorIP, args)
	resp = strings.TrimSpace(resp)
	if err != nil {
		logf.Log.Info("Running agent failed", "error", err)
		return "", err
	}
	if resp != "" { // connect should be silent
		return "", fmt.Errorf("nvme connect returned with %s", resp)
	}

	// nvme list returns all nvme devices in form n * [ ... <Node> ... <Model> ... \n]
	// we want the device (=Node) associated with Model = "Mayastor NVMe controller"
	// Node is typically "/dev/nvme0n1" and the partition "nvme0n1p2"
	retryCount := 0
	devicePath := ""
	deviceOnly := ""
	found := false
	for retryCount < maxRetries && !found {
		time.Sleep(5 * time.Second)
		retryCount++

		output, err := agent.Exec(initiatorIP, "nvme list --output-format=json")
		if output == "" || err != nil {
			logf.Log.Info("nvme list failed", "output", output, "err", err)
			continue
		}
		list := make(map[string][]map[string]string)
		if err = json.Unmarshal([]byte(output), &list); err == nil {
			logf.Log.Info("Failed to unmarshal target", "output", output)
			continue
		}
		devices := list["Devices"]
		lastConnectedDevice := devices[len(devices)-1] // Get the last connected device
		devicePath = lastConnectedDevice["DevicePath"]

		// devicePath = devicePath + "p2"
		deviceOnly = devicePath[5:] // remove the /dev/ prefix
		logf.Log.Info("", "Device", deviceOnly)
		found = true
	}

	if !found {
		return "", fmt.Errorf("Failed to get device path")
	}

	// checksum the device
	// the returned format is <checksum> <size> <device>
	// e.g. "924018992 61849088 /dev/nvme0n1p2"
	args = "cksum " + devicePath
	cksumText, err := agent.Exec(initiatorIP, args)
	if err != nil {
		logf.Log.Info("Running agent failed", "error", err)
		return "", err
	}
	cksumText = strings.TrimSpace(cksumText)
	logf.Log.Info("Executed", "cmd", args, "got", cksumText)
	// double check the response contains the device name
	if !strings.Contains(cksumText, deviceOnly) {
		return "", fmt.Errorf("Unexpected result from cksum %v", cksumText)
	}

	args = "nvme disconnect -n" + nqn
	resp, err = agent.Exec(initiatorIP, args)
	if err != nil {
		logf.Log.Info("Running agent failed", "error", err)
		return "", err
	}
	logf.Log.Info("Executing", "cmd", args, "got", resp)

	// check that the device no longer exists
	resp, err = agent.Exec(initiatorIP, "ls /dev/")
	if err != nil {
		logf.Log.Info("Running agent failed", "error", err)
		return "", err
	}
	if strings.Contains(resp, deviceOnly) {
		return "", fmt.Errorf("Device %s still exists", deviceOnly)
	}
	return cksumText, nil
}

// ExcludeNexusReplica - ensure the volume has no nexus-local replica
// This depends on there being an unused mayastor instance available so
// e.g. a 2-replica volume needs at least a 3-node cluster
func ExcludeNexusReplica(nexusIP string, nexusUuid string, volUuid string) (bool, error) {
	// get the nexus local device
	var nxlist []string
	nxlist = append(nxlist, nexusIP)
	if !mayastorclient.CanConnect() {
		return false, fmt.Errorf("gRPC calls not enabled")
	}
	nexusList, err := mayastorclient.ListNexuses(nxlist)
	if err != nil {
		return false, fmt.Errorf("Failed to list nexuses, err=%v", err)
	}
	if len(nexusList) == 0 {
		return false, fmt.Errorf("Expected to find at least 1 nexus")
	}

	nxChild := ""
	for _, nx := range nexusList {
		if nx.Uuid == nexusUuid {
			for _, ch := range nx.Children {
				if strings.HasPrefix(ch.Uri, "bdev:///") {
					if nxChild != "" {
						return false, fmt.Errorf("More than 1 nexus local replica found")
					}
					nxChild = ch.Uri
				}
			}
			if nxChild == "" { // there is no local replica so we are done
				return false, nil
			}
			break
		}
	}
	if nxChild == "" {
		return false, fmt.Errorf("failed to find the nexus")
	}

	// fault the replica
	logf.Log.Info("Faulting local replica", "replica", nxChild)
	err = mayastorclient.FaultNexusChild(nexusIP, nexusUuid, nxChild)
	if err != nil {
		return false, fmt.Errorf("Failed to fault child, err=%v", err)
	}

	// wait for the replica to disappear from the msv
	const sleepTime = 10
	const timeOut = 240
	var found bool
	for ix := 0; ix < (timeOut-1)/sleepTime; ix++ {
		found = false
		replicas, err := GetMsvReplicas(volUuid)
		if err != nil {
			return false, fmt.Errorf("Failed to get replicas, err=%v", err)
		}
		for _, r := range replicas {
			if r.Uri == nxChild {
				found = true
				break
			}
		}
		if !found {
			break
		}
		time.Sleep(sleepTime * time.Second)
	}
	if found {
		return true, fmt.Errorf("timed out waiting for faulted replica to be removed")
	}
	// wait for the msv to become healthy - now rebuilt with a non-nexus replica
	state := ""
	for ix := 0; ix < (timeOut-1)/sleepTime; ix++ {
		state, err = GetMsvState(volUuid)
		if err != nil {
			return false, fmt.Errorf("Failed to get state, err=%v", err)
		}
		if state == controlplane.VolStateHealthy() {
			break
		}
		time.Sleep(sleepTime * time.Second)
	}
	if state != controlplane.VolStateHealthy() {
		return true, fmt.Errorf("timed out waiting for volume to become healthy")
	}
	return true, nil
}
